import streamlit as st
import pandas as pd
import numpy as np
from tirages_sas import STRATIFICATION, allocations_proportionnelles, repartition_neyman
from estimation import tableau_resultats

def page_sas():
    st.title("üéØ Tirage SAS (Sondage Al√©atoire Simple)")
    st.markdown("Cette page vous permet d‚Äôeffectuer un tirage al√©atoire simple avec diff√©rentes strat√©gies.")

    if "data" not in st.session_state:
        st.warning("Veuillez d'abord importer une base de donn√©es via l'onglet 'Chargement des donn√©es'.")
        return

    data = st.session_state["data"].copy()
    colonnes_qualitatives = data.select_dtypes(include=["object", "category"]).columns.tolist()

    st.subheader("üîç Choix du plan")
    plan = st.radio("Type de tirage", ["Tirage global", "Tirage stratifi√©"], horizontal=True)

    st.subheader("üé≤ M√©thode de tirage")
    methode = st.radio("S√©lectionnez une m√©thode :", [
        "sas_sans_remise", "sas_avec_remise", "bernoulli", "tri_aleatoire",
        "selection_rejet", "draw_by_draw", "reservoir"
    ], horizontal=True)

    if plan == "Tirage global":
        n = st.number_input("Taille de l‚Äô√©chantillon souhait√©e", min_value=1, max_value=len(data), value=10)
        if st.button("üé≤ Lancer le tirage global"):
            try:
                # Suppression des NaN dans l'√©chantillon global avant le tirage
                data_clean = data.dropna(subset=["Y"])  # Ne garder que les lignes o√π "Y" n'est pas NaN
                echantillon = STRATIFICATION(data_clean.assign(Strate='A'), {'A': n}, mode=methode)
                st.success(f"‚úÖ Tirage effectu√©. √âchantillon de {len(echantillon)} unit√©s.")
                st.dataframe(echantillon.dropna())

                # ======== Estimation sur la variable Y (tirage global) =========
                st.markdown("---")
                st.subheader("üìä R√©sultats d'estimation sur la variable d'int√©r√™t")

                if "Y" in echantillon.columns:
                    echantillon_clean = echantillon.dropna(subset=["Y"])  # Filtrer les NaN de Y dans l'√©chantillon final
                    y = echantillon_clean["Y"]
                    N_pop = len(data_clean)  # Population totale apr√®s suppression des NaN dans "Y"
                    pik_value = n / N_pop
                    pik = np.full(len(echantillon_clean), pik_value)

                    rho = 1
                    pik1 = np.outer(pik, pik)
                    pikl = rho * pik1
                    np.fill_diagonal(pikl, pik)

                    resultats = tableau_resultats(y, pik, pikl, N=N_pop, alpha=0.05)
                    st.dataframe(resultats.style.format(precision=3).set_caption("Tableau des r√©sultats statistiques"))

                    with st.expander("‚ÑπÔ∏è Hypoth√®ses utilis√©es"):
                        st.markdown(""" 
                        Les estimateurs affich√©s sont :
                        - **Moyenne empirique** 
                        - **Total empirique** 
                        - **H√°jek** (moyenne et total)
                        - **Horvitz-Thompson (HT)** pour le total

                        Hypoth√®ses :
                        - Probabilit√© d‚Äôinclusion **constante**
                        - **Ind√©pendance** entre les unit√©s (œÅ = 1)

                        > ‚ö†Ô∏è **Attention** : Si ces hypoth√®ses sont fausses, les r√©sultats peuvent √™tre biais√©s.
                        """)
                else:
                    st.warning("‚ö†Ô∏è La variable `Y` n‚Äôest pas pr√©sente dans l‚Äô√©chantillon final.")

            except Exception as e:
                st.error(f"‚ùå Erreur lors du tirage : {e}")

    else:
        if not colonnes_qualitatives:
            st.error("‚ùå Aucune variable qualitative n'est disponible pour la stratification.")
            return

        var_strate = st.selectbox("üî¢ Variable de stratification", colonnes_qualitatives)

        mode_repartition = st.radio("üßÆ Mode de r√©partition", ["Fixe par strate", "Proportionnelle", "Neyman"], horizontal=True)
        allocations = {}

        try:
            # Suppression des NaN avant de proc√©der √† la r√©partition
            data_clean = data.dropna(subset=[var_strate, "Y"])  # Supprime les NaN dans les colonnes n√©cessaires
            if "Strate" in data_clean.columns and var_strate != "Strate":
                data_temp = data_clean.drop(columns=["Strate"]).rename(columns={var_strate: "Strate"})
            else:
                data_temp = data_clean.rename(columns={var_strate: "Strate"})

            data_temp["Strate"] = data_temp["Strate"].astype(str)
            strates = sorted(data_temp["Strate"].unique())

            if mode_repartition == "Fixe par strate":
                st.markdown("D√©finissez la taille de l‚Äô√©chantillon pour chaque strate :")
                tailles_disponibles = data_temp["Strate"].value_counts().to_dict()
                for strate in strates:
                    max_val = tailles_disponibles.get(strate, 0)
                    taille = st.number_input(f"‚Üí {strate}", min_value=0, max_value=max_val, value=min(2, max_val), step=1, key=f"taille_{strate}")
                    allocations[strate] = taille

            elif mode_repartition == "Proportionnelle":
                n_total = st.number_input("Taille totale de l‚Äô√©chantillon", min_value=1, value=10)
                allocations = allocations_proportionnelles(data_temp, n_total)
                st.success("üìä R√©partition proportionnelle calcul√©e :")
                st.write(allocations)

            elif mode_repartition == "Neyman":
                var_quant = st.selectbox("Variable d‚Äôint√©r√™t (quantitative)", data.select_dtypes(include='number').columns)
                n_total = st.number_input("Taille totale de l‚Äô√©chantillon", min_value=1, value=10)
                allocations = repartition_neyman(data_temp, n_total, var_quant)
                st.success("üìä R√©partition selon Neyman :")
                st.write(allocations)

        except Exception as e:
            st.error(f"‚ùå Erreur dans la configuration des strates : {e}")
            return

        if st.button("üéØ Lancer le tirage stratifi√©"):
            try:
                data_clean = data.dropna(subset=[var_strate, "Y"])  # Assurez-vous de retirer les lignes NaN ici aussi
                if "Strate" in data_clean.columns and var_strate != "Strate":
                    data_temp = data_clean.drop(columns=["Strate"]).rename(columns={var_strate: "Strate"})
                else:
                    data_temp = data_clean.rename(columns={var_strate: "Strate"})

                data_temp["Strate"] = data_temp["Strate"].astype(str)
                strates_valides = data_temp["Strate"].unique()
                allocations_valides = {k: v for k, v in allocations.items() if k in strates_valides}

                if not allocations_valides:
                    st.error("‚ùå Aucune strate valide d√©tect√©e dans les allocations.")
                    return

                tailles_dispo = data_temp["Strate"].value_counts().to_dict()
                erreurs = []

                for strate, taille_demandee in allocations_valides.items():
                    taille_disponible = tailles_dispo.get(strate, 0)
                    if taille_demandee > taille_disponible:
                        erreurs.append(f"Strate '{strate}' : {taille_demandee} > {taille_disponible}")

                if erreurs:
                    st.error("‚ùå La taille demand√©e d√©passe la population disponible pour certaines strates :")
                    for msg in erreurs:
                        st.markdown(f"- {msg}")
                    return

                echantillon = STRATIFICATION(data_temp, allocations_valides, mode=methode)
                st.success(f"‚úÖ Tirage r√©ussi. Taille finale de l‚Äô√©chantillon : {len(echantillon)}")
                st.dataframe(echantillon.dropna())  # Filtrer les NaN avant d'afficher l'√©chantillon final

                csv = echantillon.dropna().to_csv(index=False).encode('utf-8')
                st.download_button("üì• T√©l√©charger l‚Äô√©chantillon", data=csv, file_name="echantillon_SAS.csv", mime='text/csv')

                # ======== Estimation sur la variable Y (tirage stratifi√©) =========
                st.markdown("---")
                st.subheader("üìä R√©sultats d'estimation sur la variable d'int√©r√™t")

                if "Y" in echantillon.columns:
                    echantillon_clean = echantillon.dropna(subset=["Y"])

                    if len(echantillon_clean) == 0:
                        st.warning("‚ö†Ô∏è Toutes les observations de la variable `Y` sont manquantes dans l‚Äô√©chantillon.")
                    else:
                        y = echantillon_clean["Y"]
                        N_pop = len(data_clean)  # Population totale apr√®s suppression des NaN dans "Y"
                        n = len(echantillon_clean)
                        pik_value = n / N_pop
                        pik = np.full(n, pik_value)

                        rho = 1
                        pik1 = np.outer(pik, pik)
                        pikl = rho * pik1
                        np.fill_diagonal(pikl, pik)

                        resultats = tableau_resultats(y, pik, pikl, N=N_pop, alpha=0.05)
                        st.dataframe(resultats.dropna().style.format(precision=3).set_caption("Tableau des r√©sultats statistiques"))

                    with st.expander("‚ÑπÔ∏è Hypoth√®ses utilis√©es"):
                        st.markdown(""" 
                        Les estimateurs affich√©s sont :
                        - **Moyenne empirique** 
                        - **Total empirique** 
                        - **H√°jek** (moyenne et total)
                        - **Horvitz-Thompson (HT)** pour le total

                        Hypoth√®ses :
                        - Probabilit√© d‚Äôinclusion **constante**
                        - **Ind√©pendance** entre les unit√©s (œÅ = 1)

                        > ‚ö†Ô∏è **Attention** : Si ces hypoth√®ses sont fausses, les r√©sultats peuvent √™tre biais√©s.
                        """)
                else:
                    st.warning("‚ö†Ô∏è La variable `Y` n‚Äôest pas pr√©sente dans l‚Äô√©chantillon final.")

            except Exception as e:
                st.error(f"‚ùå Erreur pendant le tirage : {e}")
